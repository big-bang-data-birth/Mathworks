function [featureTable,outputTable] = diagnosticFeatures(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A table or a cell array of tables/matrices containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  outputTable: A table containing the computation results.
%
% This function computes spectra:
%  data_ps/SpectrumData
%
% This function computes features:
%  data_ps_spec/PeakAmp1
%  data_ps_spec/PeakAmp2
%  data_ps_spec/PeakAmp3
%  data_ps_spec/PeakAmp4
%  data_ps_spec/PeakAmp5
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 15-Nov-2025 23:49:35

% Create output ensemble.
outputEnsemble = workspaceEnsemble(inputData,'DataVariables',"data",'ConditionVariables',"label");

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"data_ps";"data_ps_spec"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = "data";

% Initialize a cell array to store all the results.
allMembersResult = {};

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Get all input variables.
    data = readMemberData(member,"data",["Time","gs"]);

    % Initialize a table to store results.
    memberResult = table;

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";

        % Compute effective sampling rate.
        tNumeric = time2num(data.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x_raw = data.gs;
        if irregular
            x = resample(x_raw,tNumeric,Fs,'linear');
        else
            x = x_raw;
        end

        % Set Welch spectrum parameters.
        L = fix(length(x)/4.5);
        noverlap = fix(L*50/100);
        win = hamming(L);

        % Compute the power spectrum.
        [ps,f] = pwelch(x,win,noverlap,[],Fs);
        w = 2*pi*f;

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
        ps.Properties.VariableUnits = {'Hz', ''};
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        data_ps = ps;
    catch
        data_ps = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({data_ps},'VariableNames',{'data_ps'})]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = data_ps.SpectrumData;
        w = data_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*23.841796875) & (w<=factor*24414);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',10);
        peakAmp = [peakAmp(:); NaN(10-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(10-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakAmp2 = peakAmp(2);
        PeakAmp3 = peakAmp(3);
        PeakAmp4 = peakAmp(4);
        PeakAmp5 = peakAmp(5);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakAmp2,PeakAmp3,PeakAmp4,PeakAmp5];

        % Store computed features in a table.
        featureNames = {'PeakAmp1','PeakAmp2','PeakAmp3','PeakAmp4','PeakAmp5'};
        data_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Store computed features in a table.
        featureValues = NaN(1,5);
        featureNames = {'PeakAmp1','PeakAmp2','PeakAmp3','PeakAmp4','PeakAmp5'};
        data_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({data_ps_spec},'VariableNames',{'data_ps_spec'})]; %#ok<AGROW>

    % Append all member results to the cell array.
    allMembersResult = [allMembersResult; {memberResult}]; %#ok<AGROW>
end

% Write the results for all members to the ensemble.
writeToMembers(outputEnsemble,allMembersResult)

% Gather all features into a table.
selectedFeatureNames = ["data_ps_spec/PeakAmp1","data_ps_spec/PeakAmp2","data_ps_spec/PeakAmp3","data_ps_spec/PeakAmp4","data_ps_spec/PeakAmp5"];
featureTable = readFeatureTable(outputEnsemble,'Features',selectedFeatureNames);

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');

% Gather results into a table.
if nargout > 1
    outputTable = readall(outputEnsemble);
end
end
